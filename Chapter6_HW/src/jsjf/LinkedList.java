package jsjf;import jsjf.exceptions.*;import java.util.*;/** * LinkedList represents a linked implementation of a list. *  * @author Lewis and Chase * @version 4.0 */public abstract class LinkedList<T extends Comparable <T>> implements ListADT<T>, Iterable<T>{    protected int count;    protected LinearNode<T> head, tail;	protected int modCount;         /**     * Creates an empty list.     */    public LinkedList()    {        count = 0;        head = tail = null;		modCount = 0;	}       /**     * Removes the first element in this list and returns a reference     * to it. Throws an EmptyCollectionException if the list is empty.     *     * @return a reference to the first element of this list     * @throws EmptyCollectionException if the list is empty     */    public T removeFirst() throws EmptyCollectionException    {        if (isEmpty())            throw new EmptyCollectionException("LinkedList");        LinearNode<T> temp = head;                head = head.getNext();        count--;        modCount--;        return head.getElement();        // To be completed as a Programming Project    }       /**     * Removes the last element in this list and returns a reference     * to it. Throws an EmptyCollectionException if the list is empty.     *     * @return the last element in this list     * @throws EmptyCollectionException if the list is empty         */    public T removeLast() throws EmptyCollectionException    {        LinearNode<T> temp = head;        if (isEmpty())            throw new EmptyCollectionException("LinkedList");        while(temp.getNext().getNext()!=null)            temp = temp.getNext();        temp.setNext(null);        tail = temp;        return tail.getElement();    }       /**     * Removes the first instance of the specified element from this     * list and returns a reference to it. Throws an EmptyCollectionException      * if the list is empty. Throws a ElementNotFoundException if the      * specified element is not found in the list.     *     * @param  targetElement the element to be removed from the list     * @return a reference to the removed element     * @throws EmptyCollectionException if the list is empty	 * @throws ElementNotFoundException if the target element is not found     */    public T remove(T targetElement) throws EmptyCollectionException,          ElementNotFoundException     {        if (isEmpty())            throw new EmptyCollectionException("LinkedList");                LinearNode<T> tmp = head;        LinearNode<T> refNode = null;        System.out.println("Traversing to all nodes..");        /**         * Traverse till given element         */        while(true)        {            if(tmp == null){                break;            }            if(tmp.getElement().compareTo(targetElement) == 0){                //found the target node, add after this node                refNode = tmp;                break;            }            tmp = tmp.getNext();        }        if(refNode != null)            {                tmp = refNode.getNext();                refNode.setNext(tmp.getNext());                            if(refNode.getNext() == null)                    {                        tail = refNode;                    }                            System.out.println("Deleted: "+tmp.getElement());            }                 else             {            System.out.println("Unable to find the given element...");            }        return 	refNode.getElement();    }       /**     * Returns the first element in this list without removing it.      *     * @return the first element in this list	 * @throws EmptyCollectionException if the list is empty     */    public T first() throws EmptyCollectionException    {        if (isEmpty())                throw new EmptyCollectionException("LinkedList");        return head.getElement();    }	    /**     * Returns the last element in this list without removing it.      *     * @return the last element in this list  	 * @throws EmptyCollectionException if the list is empty     */    public T last() throws EmptyCollectionException    {        if (isEmpty())            throw new EmptyCollectionException("LinkedList");        return tail.getElement();    }	    /**     * Returns true if the specified element is found in this list and      * false otherwise. Throws an EmptyCollectionException if the list 	 * is empty.     *     * @param  targetElement the element that is sought in the list     * @return true if the element is found in this list     * @throws EmptyCollectionException if the list is empty     */    public boolean contains(T targetElement) throws          EmptyCollectionException     {        if (isEmpty())            throw new EmptyCollectionException("LinkedList");              boolean found = false;        LinearNode<T> previous = null;        LinearNode<T> current = head;              while (current != null && !found)            if (targetElement.equals(current.getElement()))                return true;            else            {                previous = current;                current = current.getNext();            }        return found;        }        /**         * Returns true if this list is empty and false otherwise.     *     * @return true if the list is empty, false otherwise     */    public boolean isEmpty()    {        if (head == null)            return true;        else            return false;// To be completed as a Programming Project    }    /**     * Returns the number of elements in this list.     *     * @return the number of elements in the list     */    public int size()    {        return count;// To be completed as a Programming Project    }    /**     * Returns a string representation of this list.     *     * @return a string representation of the list         */    public String toString()    {       String result = "List: ";       LinearNode<T> current = head;       while(current.getNext() != null)       {           result += current.getElement() + ", ";           current = current.getNext();       }        return result;    }    public void traverse()    {                 LinearNode<T> temp = head;        while(true){            if(temp == null){                break;            }            System.out.println(temp.getElement());            temp = temp.getNext();        }    }    /**     * Returns an iterator for the elements in this list.      *     * @return an iterator over the elements of the list     */    public Iterator<T> iterator()    {        return new LinkedListIterator();    }	/**	 * LinkedIterator represents an iterator for a linked list of linear nodes.	 */	private class LinkedListIterator implements Iterator<T>	{		private int iteratorModCount;  // the number of elements in the collection		private LinearNode<T> current;  // the current position				/**		 * Sets up this iterator using the specified items.		 *		 * @param collection  the collection the iterator will move over		 * @param size        the integer size of the collection		 */		public LinkedListIterator()		{			current = head;			iteratorModCount = modCount;		}				/**		 * Returns true if this iterator has at least one more element		 * to deliver in the iteration.		 *		 * @return  true if this iterator has at least one more element to deliver		 *          in the iteration		 * @throws  ConcurrentModificationException if the collection has changed		 *          while the iterator is in use		 */		public boolean hasNext() throws ConcurrentModificationException		{			if (iteratorModCount != modCount) 				throw new ConcurrentModificationException();						return (current != null);		}				/**		 * Returns the next element in the iteration. If there are no		 * more elements in this iteration, a NoSuchElementException is		 * thrown.		 *		 * @return the next element in the iteration		 * @throws NoSuchElementException if the iterator is empty		 */		public T next() throws ConcurrentModificationException		{			if (!hasNext())				throw new NoSuchElementException();						T result = current.getElement();			current = current.getNext();			return result;		}				/**		 * The remove operation is not supported.		 * 		 * @throws UnsupportedOperationException if the remove operation is called		 */		public void remove() throws UnsupportedOperationException		{			throw new UnsupportedOperationException();		}	}}